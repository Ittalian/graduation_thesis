<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta content="text/html; charset=UTF-8" />
  <title>第十回: 意味解析と中間表現</title>
  <meta name="generator" content="amaya 9.0, see http://www.w3.org/Amaya/" />
  <link href="../../stylesheets/slide-screen.css" rel="stylesheet"
  type="text/css" media="screen" />
  <link href="../../stylesheets/slide-proj.css" rel="stylesheet"
  type="text/css" media="projection" />
  <link href="../../stylesheets/slide-print.css" rel="stylesheet"
  type="text/css" media="print" />
  <style type="text/css">
  </style>
</head>

<body>
<h1 style="text-align: center;"><strong>言語理論とコン
パイラ</strong></h1>

<p style="text-align: center;"><strong>第</strong><strong>十回:
意味解析と中間表現</strong></p>

<p style="text-align: center;"></p>

<p><a
href="http://www.sw.it.aoyama.ac.jp/2005/Language%20Theory%20and%20Compilers/lecture9.html">http://www.sw.it.aoyama.ac.jp/2005/Language%20Theory%20and%20Compilers/lecture9.html</a></p>

<p class="letterhead"><a href="http://www.aoyama.ac.jp/"><img alt="AGU"
src="../../stylesheets/aoyamalogo.jpg" /></a></p>

<p class="signature">© 2005 <a href="mailto:duerst@it.aoyama.ac.jp">Martin
J. Dürst</a> <a href="http://www.aoyama.ac.jp/">青山学院大学</a></p>

<h1>今日の予定</h1>
<ul>
  <li>先週からの宿題</li>
  <li>エラー処理</li>
  <li>中間表現 (構文木、名前表)</li>
  <li>意味解析</li>
</ul>

<h1>先週からの宿題</h1>

<p>簡単なプログラム言語を bison で実現して、bison の
<code>.y</code> ファイルを印刷して<strong></strong>提出:</p>
<ul>
  <li>データ型は整数のみ</li>
  <li>変数の識別子は一文字 (A-Za-z), 初期値は 0</li>
  <li>多くの C の演算子を実現する</li>
  <li>演算子の優先度、結合規則を文法で定義する (%left,
    %right など使わないこと)</li>
  <li>文は <code>;</code> で区切る。制御文 (<code>if</code>
    等)、関数 は無し</li>
  <li><code>@ (<var>式</var>)</code>
    は「式」の結果を改行付きに印刷する。</li>
</ul>

<h1>宿題関連のプリント</h1>
<ul>
  <li><a href="calc.y">calc.y</a> (3枚): bison
    の入力ファイル、正解の一例</li>
  <li><a href="calc.bat">calc.bat</a>, <a href="test.in">test.in</a>, <a
    href="test.out">test.out</a> (合せて 1枚):
    テスト用スクリプト、入力、期待された出力</li>
  <li><a href="svn.log">svn.log</a> (1枚): <a
    href="http://subversion.tigris.org/">subversion</a>
    バージョン管理システムからの開発記録</li>
</ul>

<h1>宿題の要点</h1>
<ul>
  <li>優先度: 式の種類 (項、因子など)
  ごとに非終端記号</li>
  <li>結合規則: 左結合に左再帰、右結合に右再帰</li>
  <li>変数:
    グローバル変数の配列を用意して、文字の番号を指数に</li>
  <li>演算子ごとに必要な処理: C に任せる</li>
</ul>

<h1>言語理論のまとめ</h1>

<table border="1">
  <tbody>
    <tr>
      <td>文法</td>
      <td>Type</td>
      <td>言語</td>
      <td>オートマトン</td>
    </tr>
    <tr>
      <td>句構造文法</td>
      <td>0</td>
      <td>句構造言語</td>
      <td>チューリング機械</td>
    </tr>
    <tr>
      <td>文脈依存文法</td>
      <td>1</td>
      <td>文脈依存言語</td>
      <td>線形拘束オートマトン</td>
    </tr>
    <tr>
      <td>文脈自由文法</td>
      <td>2</td>
      <td>文脈自由言語</td>
      <td>プッシュダウンオートマトン</td>
    </tr>
    <tr>
      <td>正規文法</td>
      <td>3</td>
      <td>正規言語</td>
      <td>有限オートマトン</td>
    </tr>
  </tbody>
</table>

<h1>構文エラー処理</h1>
<ul>
  <li>エラー処理の難しさ</li>
  <li>エラー処理の要点</li>
  <li>エラーの技法</li>
</ul>

<h1>エラー処理の難しさ</h1>
<ul>
  <li>一つの正しいプログラムに対してエラーのプログラムは多数ある</li>
  <li>人間にとって間違いやすいものと間違いにくいものはプログラムに区別できない</li>
  <li>構文解析には理論があるが、エラー処理には理論がない</li>
</ul>

<h1>エラー処理の要点</h1>
<ul>
  <li>分かりやすいエラーメッセージを出す</li>
  <li>一つだけではなく、複数のエラーを見つける</li>
  <li>二次エラーをできるだけ出さない</li>
  <li>正しいプログラムの処理を遅くさせない</li>
  <li>コンパイラを複雑しすぎない</li>
</ul>

<h1>エラー処理の技法</h1>
<ul>
  <li>文法に合ったトーケンを見つけるまでにトーケンを捨てる
    (panic mode)</li>
  <li>少数のトーケンを追加又は入れ替える</li>
  <li>文法にエラーをキャッチする規則を追加する</li>
  <li>入力に一番近い正しいプログラムを探す</li>
</ul>

<h1>bison でのエラー処理</h1>
<ul>
  <li><code>error</code> トーケンを文法に追加できる</li>
  <li>エラーが起こると bison が一番近い <code>error</code>
    トーケンの含まれる規則までエラー前のトーケンや非終端記号を捨てる</li>
  <li>その規則の <code>error</code>
    トーケンの後に来るトーケンが来る入力も捨てる</li>
</ul>

<h1>コンパイラの段階</h1>

<p>字句解析 (lexical analysis)</p>

<p>構文解析 (parsing; syntax analysis)</p>

<p>意味解析 (semantic analysis)</p>

<p>最適化 (optimization)</p>

<p>コード生成 (code generation)</p>

<h1>中間表現: 名前表</h1>
<ul>
  <li>提供する機能:
    <ul>
      <li>名前の検索</li>
      <li>名前の登録と取り消し</li>
      <li>名前についてのデータの管理</li>
    </ul>
  </li>
  <li>要点:
    <ul>
      <li>使うことが多くて、名前の数が多いので効率が大切</li>
      <li>同じ名前が複数ある可能性があるので区別が必要</li>
    </ul>
  </li>
</ul>

<h1>名前表が扱うデータ</h1>
<ul>
  <li>名前の種類 (変数、関数、型など)</li>
  <li>定義か宣言だけか</li>
  <li>変数、関数などの型</li>
  <li>名前が有効な領域 (例えば関数、ブロック)</li>
  <li>変数などの場合: 大きさ</li>
  <li>関数、変数などのアドレス</li>
</ul>

<h1>中間表現: 構文木</h1>

<p>簡単なプログラム言語と簡単なマシーン・アーキテクチャの場合
(例えば Pascal からスタック・マシーン)
には構文解析しながらコード生成を行うこともある</p>

<p>構文木の生成:
構文規則ごとの処理で再生する。例えば:</p>

<p><code>expression: expression '+' term { $$ = $1 + $3; }</code></p>

<p>を次に変える:</p>
<pre>expression: expression '+' term<code><br /></code>            { $$ = newnode(PLUS, $1, $3; }</pre>

<p>(<code>YYSTYPE</code> も変える)</p>

<p>構文木は普通二分木が、関数の引数などに特別な措置が必要</p>

<h1>意味解析</h1>
<ul>
  <li>主に型の処理:
    <ul>
      <li>型が合うかどうかのチェック</li>
      <li>必要に応じて型の自動変換
        (構文木に新たなノードの追加)</li>
    </ul>
  </li>
  <li>構文木の生成の時にするか後にするか</li>
  <li>型が同じかどうか複数の定義がある:
    <ul>
      <li>同じ名前の型が同じ
        (簡単だが利用者にとって不便)</li>
      <li>同じ中身の型が同じ (複雑)</li>
    </ul>
  </li>
</ul>
</body>
</html>
