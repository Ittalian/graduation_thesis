<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
  <meta content="text/html; charset=UTF-8" />
  <title>第十三回:
  実行環境、仮想計算機、ゴミ集め、動的コンパイラ</title>
  <meta name="generator" content="amaya 9.5, see http://www.w3.org/Amaya/" />
  <link href="../../stylesheets/slide-screen.css" rel="stylesheet"
  type="text/css" media="screen" />
  <link href="../../stylesheets/slide-proj.css" rel="stylesheet"
  type="text/css" media="projection" />
  <link href="../../stylesheets/slide-print.css" rel="stylesheet"
  type="text/css" media="print" />
  <style type="text/css">
  </style>
</head>

<body>
<h1
style="text-align: center;"><strong>言語理論とコンパイラ</strong></h1>

<p
style="text-align: center;"><strong>第十</strong><strong>三回:</strong>
実行環境、仮想計算機、ゴミ集め、動的コンパイラ</p>

<p style="text-align: center;">2006 年 7月14日</p>

<p style="text-align: center"><a
href="http://www.sw.it.aoyama.ac.jp/2006/Compiler/lecture13.html">http://www.sw.it.aoyama.ac.jp/2006/Compiler/lecture13.html</a></p>

<p class="letterhead"><a href="http://www.aoyama.ac.jp/"><img alt="AGU"
src="../../stylesheets/aoyamalogo.jpg" /></a></p>

<p class="signature">© 2006 <a href="mailto:duerst@it.aoyama.ac.jp">Martin
J. Dürst</a> <a href="http://www.aoyama.ac.jp/">青山学院大学</a></p>

<h1>目次</h1>
<ul>
  <li>期末試験について</li>
  <li>実行環境</li>
  <li>ゴミ集め</li>
  <li>仮想計算機</li>
  <li>動的コンパイル</li>
</ul>

<h1>期末試験について</h1>

<p>日時: 7月28日 (金曜日) 11:10-12:35 (85分)</p>

<p><a href="index.html">全体の資料</a></p>

<p><a href="Exam2005/LTC.html">2005 年の試験問題</a>
(問題の番号などが見えるようにするには最新のブラウザ
(例えば Opera) が必要。 解答 (例)
を見るにはスタイルシートを切り替える必要がある。)</p>

<h1>先週の宿題</h1>

<p>問題: <code>if (a==5 || b==10) { c = 12; }</code> を<a
href="lecture12.html#simpleAssembler">超単純アセンブリ言語</a>に変換
(コード生成) する</p>
<pre>        LOAD    R1, a
        CONST   R2, 5
        SUB     R1, R1, R2
        JUMP=   R1, if1
        LOAD    R1, b
        CONST   R2, 10
        SUB     R1, R1, R2
        JUMP!=  R1, else1
if1:    CONST   R1, 12
        STORE   c, R1
else1:</pre>

<h1>再配置可能プログラム</h1>
<ul>
  <li>コンパイラはソースプログラム一つを再配置可能プログラム一つにコンパイルするのが多い</li>
  <li>例: <code>.c</code> や <code>.cpp</code> ファイルを
    <code>.o</code> や <code>.obj</code> ファイル</li>
  <li>主な中身:
    <ul>
      <li>機械コード</li>
      <li>定数</li>
      <li>未定義のシンボルのリスト</li>
      <li>外部参照可能なシンボルのリスト</li>
    </ul>
  </li>
  <li>中身の検証: cygwin などの <code>nm</code> コマンド</li>
</ul>

<h1>実行環境</h1>

<p>コンパイラと一緒に用意する必要がある</p>
<ul>
  <li>コマンドラインからの引数の渡し</li>
  <li>環境変数の渡し</li>
  <li>メモリ管理</li>
  <li>例外処理</li>
  <li>入出力など様々なライブラリ</li>
</ul>

<h1>従来の動的メモリの仕組み</h1>
<ul>
  <li>C での動的メモリの仕組み:
    <ul>
      <li>メモリを「生のまま」malloc で用意する</li>
      <li>free で使い終わったメモリをシステムに返す</li>
    </ul>
  </li>
  <li>C++ での動的メモリの仕組み:
    <ul>
      <li>new で新しいオブジェクトを作る</li>
      <li>delete で使い終わったメモリをシステムに返す</li>
    </ul>
  </li>
  <li>問題点:
    <ul>
      <li>用意するところと返すところが違う</li>
      <li>メモリの返し忘れ (memory leak)</li>
    </ul>
  </li>
  <li>対応:
    <ul>
      <li>特別なツール (<a href="http://dmalloc.com/">dmalloc</a>, <a
        href="http://www-306.ibm.com/software/awdtools/purify/">Purify</a>
        など)</li>
      <li>ゴミ集め</li>
    </ul>
  </li>
</ul>

<h1>ゴミ集めの仕組み</h1>
<ul>
  <li>言語は変数などの型を分かるので、動的メモリのどの部分が参照されているか計算は可能</li>
  <li>参照されなくなった部分は使えないので再利用してよい</li>
  <li>これはゴミ集め (garbage collection) と言う</li>
  <li>動的メモリを自動的に管理する言語が増えている
    (Java, Perl 等々)</li>
  <li>ゴミ集めの利点:
    <ul>
      <li>プログラマはメモリを返さなくて済む。プログラムを書く効率が上がる。</li>
      <li>memory leak がなくなる</li>
    </ul>
  </li>
  <li>ゴミ集めの問題点:<br />

    <ul>
      <li>ゴミ集めに時間がかかる
        (ゴミ集めのために急にプログラムが止まることがある)</li>
    </ul>
  </li>
</ul>

<h1>ゴミ集めの手法</h1>

<p>要点: できるだけ普通の処理と同時に少しづつ進める</p>
<ol>
  <li>動的メモリの部分が参照されている数 (reference count)
    を記録・更新り、0 になったらゴミとして集める。
    <ul>
      <li>問題点: 参照のサイクルが残る可能性がある</li>
    </ul>
  </li>
  <li>印掃式 (mark and sweep):
    全ての動的メモリの部分に印を付けて、これを最初に
    off
    にする。静的メモリなどから参照可能な動的メモリの部分の印を
    on にする。印が off
    になっている部分をゴミとして集める。</li>
  <li>複写式 (copy):
    動的メモリ領域を二つ用意して、参照されている動的メモリの部分をコピーする。
    <ul>
      <li>利点: 動的メモリの整理</li>
      <li>問題点: メモリが二倍必要</li>
    </ul>
  </li>
</ol>

<h1>仮想計算機</h1>
<ul>
  <li>目的: 移植性の向上、 コンパイラの単純化</li>
  <li>仕組み:
    <ul>
      <li>(実際存在しない機械の)
        機械コードにプログラムをコンパイルする</li>
      <li>このコードを解釈・実行するプログラム (emulator)
        を用意する</li>
    </ul>
  </li>
  <li>例: Pascal, Java (JVM), Perl, ... の実装<br />
    MacIntosh: 680x0 を PowerPC で実装</li>
  <li>類似物: <a href="http://www.vmware.com/">VMWare</a>, <a
    href="http://www.microsoft.com/windows/virtualpc/default.mspx">Virtual
    PC</a>, <a href="http://www.winehq.com/">wine</a>, <a
    href="http://www.cygwin.com/">cygwin</a></li>
  <li>問題点: 機械コードより遅い
  (一般的に三倍から十倍)</li>
</ul>

<h1>動的コンパイル</h1>
<ul>
  <li>目的: 仮想計算機などの効率化</li>
  <li>仕組み (プログラム実行中):
    <ul>
      <li>よく使われるコード (例えば関数、繰り返し)
        の割り出し</li>
      <li>このコードをできるだけ機械の命令に置き換える</li>
    </ul>
  </li>
  <li>高度な技法:
    <ul>
      <li>よく使われる引数の値などを割り出し、それ専用のコードの枝分かれを用意する</li>
    </ul>
  </li>
  <li>問題点: 高度な技術が必要</li>
</ul>
<ul>
</ul>
</body>
</html>
