<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
  <meta content="text/html; charset=UTF-8" />
  <title>第八回: yacc 系ツールの使い方</title>
  <meta name="generator" content="amaya 9.5, see http://www.w3.org/Amaya/" />
  <link href="../../stylesheets/slide-screen.css" rel="stylesheet"
  type="text/css" media="screen" />
  <link href="../../stylesheets/slide-proj.css" rel="stylesheet"
  type="text/css" media="projection" />
  <link href="../../stylesheets/slide-print.css" rel="stylesheet"
  type="text/css" media="print" />
  <style type="text/css">
  </style>
</head>

<body>
<h1
style="text-align: center;"><strong>言語理論とコンパイラ</strong></h1>

<p style="text-align: center;"><strong>第八</strong><strong>回:</strong>
<a href="lecture8.html">yacc 系ツールの使い方</a></p>

<p style="text-align: center;">2005 年 6月 16日</p>

<p class="letterhead"><a href="http://www.aoyama.ac.jp/"><img alt="AGU"
src="../../stylesheets/aoyamalogo.jpg" /></a></p>

<p class="signature">© 2006 <a href="mailto:duerst@it.aoyama.ac.jp">Martin
J. Dürst</a> <a href="http://www.aoyama.ac.jp/">青山学院大学</a></p>

<h1>先週の宿題</h1>

<p>提出: 6月16日 (金) 10:45 までに O 棟 529 号室の前; A4
一枚</p>

<p>次の文法の曖昧性を除去し、曖昧性のない文法を提出しなさい。曖昧性がないことを複数の例で確認してください。</p>

<p><code>E → E '+' E</code>    (Expression, 式)</p>

<p><code>E → E '*' E</code></p>

<p><code>E → '(' E ')'</code></p>

<p><code>E → integer</code></p>

<p>ヒント: 非終端記号の追加が必要</p>

<p>ヒント:
高校とかで覚えた「項」と「因子」を思い出してください。</p>

<h1>解析の実装: 下向き解析と上向き解析</h1>
<dl>
  <dt>下向き構文解析 (top-down parsing):</dt>
    <dd>解析木を上から (初期記号から) 作る</dd>
  <dt>上向き構文解析 (bottom-up parsing):</dt>
    <dd>解析木を下から (終端記号から) 作る</dd>
    <dd>途中に複数の (小さな) 解析木がある</dd>
</dl>

<h1>下向き解析の一般概要</h1>
<ul>
  <li>文法を初期記号から展開する</li>
  <li>選択肢があれば順番に試してみる</li>
  <li>終端記号まで展開したらこれを入力と比べる
    <ul>
      <li>合ったら続く</li>
      <li>合わなかったら戻って
        (バックトラック)、違う選択を試す</li>
    </ul>
  </li>
</ul>

<p>バックトラックは時間がかかる上、避けた方がいいとされた</p>

<p>次のトーケンしか見なくて良い文法に限定したい</p>

<h1>再帰的下向き構文解析</h1>
<ul>
  <li>下向き構文解析は非終端記号ごとに関数一つを作成</li>
  <li>文法に再帰的な要素がある<br />
    例 (代入式/assignement operation): <code>A → variable '=' A |
    integer</code><br />
  </li>
</ul>

<h1>左再帰の問題と解決</h1>

<p>左再帰の例:</p>

<p><code>E → E '+' integer | integer</code></p>

<p>間違った解消 (結合規則が違う):</p>

<p><code>E → integer '+' E | integer</code></p>

<p>解消の結果:</p>

<p><code>E → integer EE</code></p>

<p><code>EE → '+' integer EE | ε</code></p>

<h1>文法規則と BNF</h1>

<p>文法規則には色々な書き方がある:</p>
<ol>
  <li>一番単純な書き方: 矢印だけ</li>
  <li>左側に同じ被終端記号を持つものを複数組み合わせて
    | で選択を表す<br />
    ⇒ 根本的に 1. と変わらない (syntactic sugar/糖衣構文)</li>
  <li>正規表現の ? の様なもの (あり/無し) の追加 (よく
    [...] で書く)<br />
    ⇒ 二つの構文規則に分けることが可能</li>
  <li>正規表現の * の様なもの (よく {...} で書く)<br />
    ⇒ 書き換えが可能</li>
</ol>

<p>上記の拡張を含む文法規則の書き方は BNF (Backus-Naur
Form), EBNF (Extended...), ABNF (Augmented...) などという</p>

<h1>EBNF の書き換え</h1>

<p><code>D → a E* b</code></p>

<p>⇒</p>

<p><code>D → a F b<br />
F → F E | ε</code></p>

<h1>下向き構文解析の実装: 簡単な手作りコンパイラ</h1>

<p>プログラム: <a href="prog.simple/scanner.h">scanner.h</a>, <a
href="prog.simple/scanner.c">scanner.c</a>, <a
href="prog.simple/parser.c">parser.c</a></p>

<h1>下向き構文解析の問題点</h1>
<ul>
  <li>効率良い構文解析のためにはかなり限られた文法が必要</li>
  <li>例:<br />

    <pre>factor → functioncall | variable | arrayelement
functioncall → identifier '(' parameters ')'
variable → identifier
arrayelement → identifier '[' expression ']'</pre>
  </li>
  <li><code>factor</code>
    でどこの規則を選べば良いのか分からない</li>
</ul>

<h1>最左導出と最右導出</h1>

<p>簡単な例:</p>

<p><code>E → F '+' F<br />
F → integer</code></p>

<p>最左導出の場合にはいつもできるだけ左の終端記号が置き換えられている</p>

<h1>文法の種類の呼び方</h1>
<ul>
  <li>LL: 左から入力を読んで、最左導出</li>
  <li>LR: 左から入力を読んで、最右導出</li>
  <li>LL(1): LL で、一つトーケンを先読み</li>
  <li>LR(1): LR で、一つトーケンを先読み</li>
  <li>LALR: LR (1) の一種で、yacc など幅広く使われる</li>
</ul>

<h1>LALR 構文解析の原理</h1>

<p>スタックを使って読んだトーケンや途中の非終端記号を蓄積</p>

<p>オートマトンを使って出来るだけ簡単な操作で次のステップを決める</p>

<p>(LA)LR 構文解析の二つのオペレーション</p>
<ul>
  <li>shift:
    トーケンを一個読んで、そのトーケンをスタックにステートと一緒に詰める</li>
  <li>reduce:
    スタックの上部にあるトーケンや非終端記号を文法規則を使って一つの終端記号に変換する</li>
</ul>

<h1>属性文法</h1>

<p>(attribute(d) grammar(s)</p>

<h1>bison とは</h1>
<ul>
  <li>yacc: yet another compiler compiler</li>
  <li>Unix の普及とともに広がった</li>
  <li>compiler compiler: コンパイラを作るコンパイラ</li>
  <li>yet another: もう一つ、できた当時に compiler compiler
    が流行りで、他に名前が浮かんで来なかった</li>
  <li>bison: yacc の gnu 版</li>
</ul>

<h1>flex と bison の資料</h1>
<ul>
  <li><a href="../../system/flex_bison/">インストール方法</a></li>
  <li>flex のマニュアル (日本語):<br />
    <a
    href="http://www.linux.or.jp/JM/html/flex/man1/flex.1.html">http://www.linux.or.jp/JM/html/flex/man1/flex.1.html</a></li>
  <li>bison のマニュアル (英語):<br />
    <a
    href="http://www.gnu.org/software/bison/manual/html_mono/bison.html">http://www.gnu.org/software/bison/manual/html_mono/bison.html</a></li>
</ul>
</body>
</html>
