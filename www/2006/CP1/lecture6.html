<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
  <title>計算機実習 I - 第六回 -
  構造体、共用体、列挙型</title>
  <meta name="generator" content="amaya 9.5, see http://www.w3.org/Amaya/" />
  <link href="../../stylesheets/slide-screen.css" rel="stylesheet"
  type="text/css" media="screen" />
  <link href="../../stylesheets/slide-proj.css" rel="stylesheet"
  type="text/css" media="projection" />
  <link href="../../stylesheets/slide-print.css" rel="stylesheet"
  type="text/css" media="print" />
  <style type="text/css">
  </style>
</head>

<body>
<h1 style="text-align: center">計<acronym></acronym>算機実習 I</h1>

<h2 style="text-align: center">第六回 (2005年 5月 25日)</h2>

<h2 style="text-align: center">構造体、共用体、列挙型</h2>

<p class="letterhead"><a href="http://www.aoyama.ac.jp/"><img alt="AGU"
src="../../stylesheets/aoyamalogo.jpg" /></a></p>

<p class="signature">© 2006 <a href="mailto:duerst@it.aoyama.ac.jp">Martin
J. Dürst</a> <a href="http://www.aoyama.ac.jp/">青山学院大学</a></p>

<h1>目次</h1>
<ul>
  <li>構造体</li>
  <li>共用体</li>
  <li>列挙型</li>
  <li>先週の試験</li>
</ul>

<h1>構造体 (<code>struct</code>)</h1>
<ul>
  <li>複数のデータの組み合わせ (並び) のデータ型</li>
  <li>複数の変数を組み合わせて一つの変数として使う:
    <ul>
      <li>変数の宣言と定義</li>
      <li>代入</li>
      <li>関数の引数と戻り値 (値として渡される)</li>
    </ul>
  </li>
  <li>構造体の要素はメンバという</li>
  <li>メンバ毎にしかできない操作: 演算、入出力</li>
  <li>各々のデータの間の関係がよく分かる</li>
</ul>

<h1><code>struct</code> の簡単な例</h1>
<pre>struct person {
    char name[40];
    int height;
    int weight;
};

struct person personA = {"myName", 170, 70 };
int bmi = personA.weight*10000 / (personA.height*person.height);</pre>

<h1>プログラミング上のデータの大切さ</h1>
<ul>
  <li>生き残り期間:
    <ul>
      <li>ハード: 3-5 年</li>
      <li>ソフト: 10 年とか</li>
      <li>データ: 30 年とか</li>
    </ul>
  </li>
  <li>プログラミングでデータ構造を決めるのは関数などより大切かも</li>
</ul>

<h1><code>typedef</code> を使おう</h1>

<p>(教科書 pp. 272-274)</p>
<ul>
  <li><code>struct person</code> より <code>Person</code>
    が使いやすくて、前者は C の初期からの残り物</li>
  <li><code>struct</code> の後の識別子は無しでも良い<br />

    <pre><code>typedef struct {
    char name[40];
    ...
}</code> Person;

Person personA, personB;<br /></pre>
  </li>
</ul>

<h1><code>typedef</code> の仕組み</h1>
<ul>
  <li><code>typedef</code>
    ではあらゆるデータ型に新しい名前を付けられる</li>
  <li>プログラムが分かりやすくなることが多い</li>
  <li>変数など定義の前に <code>typedef</code>
    を書くと変数の名前が型の名前になる</li>
  <li>例:<br />
    <code>int int32;</code> ⇒<br />
    <code>typedef int int32;</code><br />
    ⇒ <code>int32 myVariable;</code>
    <p><code>int matrix[4][4];</code> ⇒<br />
    <code>typedef int matrix[4][4];</code><br />
    ⇒ <code>matrix myMatrix;</code></p>
  </li>
</ul>

<h1>オブジェクト思考への展望</h1>

<p>C++ の class は C の struct にそのデータ型専用の関数
(メゾド) をつけたものから始まる。</p>

<h1>共用体 (<code>union</code>)</h1>
<ul>
  <li>構文は <code>struct</code> と同じが、
    <ul>
      <li><code>struct は</code>メンバごと場所を確保する</li>
      <li><code>union</code>
        はメンバを重ねるので同時に一種のデータしか納まらない</li>
    </ul>
  </li>
  <li>共用体の応用
    <ul>
      <li>メモリの節約</li>
      <li>実際のビットをそのまま残すデータ変換</li>
      <li>オブジェクト指向のシムレーション (特に継承)</li>
    </ul>
  </li>
</ul>

<h1>共用体の応用例</h1>

<p>コンパイラで字句解析から構文解析へ渡されるトーケン</p>
<pre>typedef struct {
    ttype type; /* トーケンの種類: 整数、識別子など */
    union {
        int    ival; /* 整数用 */
        double dval; /* 浮動小数点数用 */
        char   name[40]; /* 識別子用 */
    } val;
} token;</pre>

<h1>列挙体 (<code>enum</code>)</h1>
<ul>
  <li>少数の物の区別に使われる<br />
    例:
  じゃんけんの手、学部・学科、銀行の口座の種類</li>
  <li>名前を使うことによってプログラムは分かりやすくなる</li>
  <li>列挙体は中身が整数 (<code>int</code>) である</li>
</ul>

<p>例 (<a
href="http://moo.sw.it.aoyama.ac.jp/mod/assignment/view.php?id=34">03C2</a>、階段じゃんけん、の分かりやすい改造):</p>
<pre>typedef enum {GUU, CHOKI, PAA} janken;
janken moveA, moveB;
...
if (moveA == PAA)
    pointA += 5;</pre>

<h1>先週の演習について: <a
href="http://moo.sw.it.aoyama.ac.jp/mod/assignment/view.php?id=66">05C2</a></h1>
<ul>
  <li>なぜ <code>gets</code> とか <code>scanf</code> の <code>%s</code>
    が危ないか
    <ul>
      <li>配列は参照渡しで関数に渡される</li>
      <li>参照されたところに入力された文字が納められる</li>
      <li>しかし、参照渡しは用意した場所の先頭の位置しか渡さない</li>
      <li>オーバする危険性が高い</li>
    </ul>
  </li>
  <li>解決策:
    <ul>
      <li><code>gets</code>
      等の代わりになる新しい関数を作る</li>
      <li>その関数には用意した場所の長さも引数として渡す</li>
      <li>その関数は安全な関数しか使わない (つまり
        <code>getchar()</code>)</li>
    </ul>
  </li>
</ul>

<h1>演習についての補助</h1>
<ul>
  <li><code>typedef</code> を積極的に使う</li>
</ul>

<h1>先週の試験について</h1>

<p>一般の印象:
人によって得意と不得意の部分が見えてきた</p>

<p>第五問で寄せられた意見・提案</p>
<ul>
  <li>演習の量を減らす・問題を簡単にする・演習を早めに打ち切る</li>
  <li>早めに帰っていいよという雰囲気を作って欲しくない</li>
  <li>講義資料は紙として欲しい</li>
  <li>ヒントがもっと欲しい → Moodle
    の質問フォーラムを積極的に活用</li>
  <li>参考文献が欲しい → <a
    href="biblio.html">参考文献のリスト</a></li>
</ul>

<h1>次回の準備</h1>
<ul>
  <li>今日の復習</li>
  <li>参考書の第 11 章 (ポインタ、pp. 282-311)
    をよく読む。分かるところと分からないところをよく考える。</li>
</ul>
</body>
</html>
