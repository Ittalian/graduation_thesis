<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
  <title>言語理論とコンパイラ: 第四回:
  字句解析の実装、flex の使い方</title>
  <meta name="generator" content="amaya 9.5, see http://www.w3.org/Amaya/" />
  <link href="../../stylesheets/slide-screen.css" rel="stylesheet"
  type="text/css" media="screen" />
  <link href="../../stylesheets/slide-proj.css" rel="stylesheet"
  type="text/css" media="projection" />
  <link href="../../stylesheets/slide-print.css" rel="stylesheet"
  type="text/css" media="print" />
  <style type="text/css">
    </style>
</head>

<body>
<h1
style="text-align: center"><strong>言語理論とコンパイラ</strong></h1>

<p style="text-align: center"><strong>第四</strong><strong>回:</strong>
正規表現と字句解析</p>

<p style="text-align: center">2006年 5月 19日</p>

<p style="text-align: center"><strong><a
href="http://www.sw.it.aoyama.ac.jp/2006/Compiler/lecture4.html">http://www.sw.it.aoyama.ac.jp/2006/Compiler/lecture4.html</a></strong></p>

<p class="letterhead"><a href="http://www.aoyama.ac.jp/"><img alt="AGU"
src="../../stylesheets/aoyamalogo.jpg" /></a></p>

<p class="signature">© 2006 <a href="mailto:duerst@it.aoyama.ac.jp">Martin
J. Dürst</a> <a href="http://www.aoyama.ac.jp/">青山学院大学</a></p>

<h1>今日の内容</h1>
<ul>
  <li>flex の動作確認</li>
  <li>NFA から DFA への変換</li>
  <li>DFA の簡単化</li>
  <li>線形文法と有限オートマトン</li>
  <li>正規表現と</li>
  <li>字句解析の概要</li>
  <li>先々週の宿題の返却</li>
</ul>

<h1>flex の動作確認</h1>
<ul>
  <li>Cygwin Bash Shell を起動</li>
  <li><code>flex -V</code> で flex のバージョン確認</li>
  <li><code>gcc -v</code> で gcc のバージョン確認 (<code>v</code>
    は小文字)</li>
  <li><code>bison -V</code> で bison のバージョン確認</li>
</ul>

<h1>今週の展望</h1>
<ul>
  <li>有限オートマトン (finite state automaton, FSA):
    決定性有限オートマトン (deterministic finite automaton, DFA)
    と非決定性有限オートマトン (non-deterministic finite
    automaton, NFA)</li>
  <li>正規文法 (regular grammar): 左線形文法 (left linear grammar)
    と 右線形文法 (right linear grammar))</li>
  <li>正規表現 (regular expression)</li>
</ul>

<p>これらは全て同じ力を持って、正規言語を定義・受理する</p>

<p>これらは字句解析に使われる</p>
<ul>
  <li>正規表現で字句解析の指定</li>
  <li>FSA は字句解析の実装</li>
</ul>

<h1>NFA から同等の DFA への変換</h1>

<p>アルゴリズムの原理:</p>
<ul>
  <li>NFA の状態の集合が DFA の状態になる</li>
  <li>NFA の初期状態とそこから ε
    遷移でいける状態の集合が DFA の初期状態になる
    (ある状態から ε 遷移で行ける状態を ε
  閉包という)</li>
  <li>NFA の受理状態を一つ以上含まれる DFA
    の状態が受理状態になる</li>
</ul>

<p>全ての DFA は (単純な) NFA でもある。全ての NFA
は同等の DFA に変換できる。</p>

<p>よって、DFA と NFA の受理能力が等しい。</p>

<p>実装は DFA
の方が簡単だが、テーブルは大きくなる可能性がある。</p>

<h1>NFA から同等の DFA への変換の一例</h1>

<p><img alt=" " src="lec3img4.png" /></p>

<table border="1">
  <caption>動作関数</caption>
  <tbody>
    <tr>
      <td></td>
      <td>ε</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td>S</td>
      <td>{A}</td>
      <td>{}</td>
      <td>{}</td>
    </tr>
    <tr>
      <td>A</td>
      <td>{}</td>
      <td>{A,C}</td>
      <td>{B}</td>
    </tr>
    <tr>
      <td>B</td>
      <td>{}</td>
      <td>{}</td>
      <td>{A}</td>
    </tr>
    <tr>
      <td>C</td>
      <td>{}</td>
      <td>{}</td>
      <td>{}</td>
    </tr>
  </tbody>
</table>

<h1>DFA の最小化</h1>

<p>ある DFA から同等の最小の DFA を次の通りに作れる:</p>
<ol>
  <li>状態を受理状態と非受理状態の二つの集合に分ける</li>
  <li>それそれの状態からどの記号でどの集合に遷移するかを調べる</li>
  <li>現在の集合を、どの記号でも同じ集合に遷移する状態の部分集合に分ける</li>
  <li>3. で変更がない時まで 2. から繰り返す</li>
</ol>

<p>最小化によって効率よい実装ができるし、二つの有限オートマトンが同等であるかどうかも簡単に調べられる。</p>

<h1>DFA の最小化の一例</h1>

<p><img alt=" " src="lec3img5.png" /></p>

<h1>文法の定義</h1>
<ul>
  <li>非終端記号の有限集合 <var>N</var></li>
  <li>終端記号の有限集合 <var>Σ</var></li>
  <li>書換規則の有限集合 <var>P</var> (生成規則ともいう)</li>
  <li>開始記号 <var>S</var> (<var>S</var> ∈ <var>N</var>,
    初期記号とも言う)</li>
</ul>

<p>文法は (<var>N</var>, <var>Σ</var>, <var>P</var>, <var>S</var>)
の四字組で定義できる。</p>

<p>書換規則は一般には悲終端記号と終端記号の列から悲終端記号と終端記号の列への規則になっている。</p>

<h1>線形文法</h1>

<table border="1">
  <caption>文法の簡単な書換規則</caption>
  <tbody>
    <tr>
      <td>規則の形</td>
      <td>名称</td>
    </tr>
    <tr>
      <td>A → aB</td>
      <td>右線形規則</td>
    </tr>
    <tr>
      <td>A → Ba</td>
      <td>左線形規則</td>
    </tr>
    <tr>
      <td>A → a</td>
      <td>定数規則</td>
    </tr>
  </tbody>
</table>

<p>左線形文法: 左線形規則と定数規則しか含まない文法</p>

<p>右線形文法: 右線形規則と定数規則しか含まない文法</p>

<p>左・右線形文法はともに線形文法と言い、正規文法とも言う</p>

<h1>(<del>左</del><ins>右</ins>)
線形文法と有限オートマトン</h1>

<p><del>左</del><ins>右</ins>線形文法と NFA の対応 (ε
が考慮外):</p>
<ul>
  <li>状態は非終端記号と対応</li>
  <li>初期状態は初期記号と対応</li>
  <li>受理状態に遷移する動作は定数規則と対応</li>
  <li>全ての動作は左線形規則と対応</li>
</ul>

<p><del>右</del><ins>左</ins>線形文法も同様
(語を右から読み込むと考えられる)</p>

<h1><del>左</del><ins>右</ins>線形文法と有限オートマトンの一例</h1>

<p><img alt="有限オートマトンの状態遷移図" src="lec3img1.png"
/></p>

<p>A → aB | bA</p>

<p>B → bA | a | aC</p>

<p>C → bA | a | aC</p>

<h1>正規表現の例</h1>

<p>計算機実習 I の演習問題: ある文章中に
<code>&amp;amp;</code>, <code>&amp;quot;</code>, <code>&amp;apos;</code>,
<code>&amp;lt;</code>, <code>&amp;gt;</code> を見つけて、それぞれ
<code>&amp;</code>, <code>"</code>, <code>'</code>, <code>&lt;</code>,
<code>&gt;</code> に変換せよ。</p>

<p>Perl で書くと次のようになる:</p>
<pre>s/&amp;quot;/"/g;
s/&amp;apos;/'/g;
s/&amp;lt;/&lt;/g;
s/&amp;gt;/&gt;/g;
s/&amp;amp;/&amp;/g;</pre>

<h1>正規表現の形式定義</h1>

<table border="1">
  <caption>アルファベットΣ 上の正規表現と表す言語</caption>
  <tbody>
    <tr>
      <td>優先度</td>
      <th>正規表現</th>
      <th>条件</th>
      <th>言語</th>
      <th>備考</th>
    </tr>
    <tr>
      <td></td>
      <td>ε, a</td>
      <td>a ∈ Σ</td>
      <td>{ε} 又は {a}</td>
      <td></td>
    </tr>
    <tr>
      <td>低い</td>
      <td>r|s</td>
      <td>r, s が正規表現</td>
      <td>L(r|s) = L(r) ∪ L(s)</td>
      <td>集合和</td>
    </tr>
    <tr>
      <td>低め</td>
      <td>rs</td>
      <td>r, s が正規表現</td>
      <td>L(rs) = L(r)L(s)</td>
      <td>連結</td>
    </tr>
    <tr>
      <td>高め</td>
      <td>r*</td>
      <td>r が正規表現</td>
      <td>L(r*) = (L(r))*</td>
      <td>閉含</td>
    </tr>
    <tr>
      <td>高い</td>
      <td>(r)</td>
      <td>r が正規表現</td>
      <td>L((r)) = L(r)</td>
      <td></td>
    </tr>
  </tbody>
</table>

<p>L(r) は r
によって表されている言語。優先度は下の方が強い。</p>

<p>正規表現を定義する言語は文法で書けるが、正規表現は文法と違って規則は一つしか使わない。</p>

<h1>優先度に要注意</h1>
<ul>
  <li>abc* と (abc)*</li>
  <li>a|b|c* と (a|b|c)*</li>
  <li>ab|c と (ab)|c</li>
</ul>

<h1>正規表現の例</h1>
<ul>
  <li>ある一個の語だけ受理できる: <code>word</code></li>
  <li>ある記号の数が奇数 (<code>(aa)*a</code>)、偶数
    (<code>(aa)*</code>)、3で割れば余りが 2
    (<code>aa(aaa)*</code>)、等</li>
  <li>語の先頭に決まった記号列がある:
  <code>abc(a|b|c)*</code></li>
  <li>語の終わりに決まった記号列がある:
    <code>(a|b|c)*abc</code></li>
  <li>語の真ん中に・どこかに決まった記号列がある:
    <code>(a|b|c)*abc(a|b|c)*</code></li>
</ul>

<h1><strong></strong>実用化された正規表現</h1>

<p>正規表現の便利な追加機能</p>
<ul>
  <li><code>.</code>: 文字一個 (<code>a|b|c|</code>...)</li>
  <li><var>r</var><code>+</code>: 一個以上の <var>r</var>
    (<var>rr</var><code>*</code>)</li>
  <li><var>r</var><code>?</code>: <var>r</var> の有無 (<var>r</var>|ε,
    その代わり ε は使わない)</li>
  <li><var>r</var><code>{</code><var>m</var><code>,</code><var>n</var><code>}</code>:
    <var>m</var> 個以上 <var>n</var> 個以下の <var>r</var>
    (<ins>r</ins>...<var>rr</var><code>?</code>...<var>r</var><code>?</code>)</li>
  <li><code>[b-f]</code>: b から f の字 (b|c|d|e|f)</li>
  <li><code>\*</code> 等: <code>\</code>
  はエスケープに使われる</li>
</ul>

<p>正規表現の使い方による変更</p>
<ul>
  <li>語全体のではなくその一部をマッチ</li>
  <li><code>^</code> と <code>$</code>
  で語の先頭と最後をマッチ</li>
  <li>括弧に相当する部分語を変数に代入</li>
</ul>

<h1>正規表現から NFA へ (1)</h1>

<p>正規表現に対応する NFA
は正規表現の部分表現から再帰的に作られる。</p>

<p>ε と a に対応する NFA
は初期状態一つと受理状態一つとそれを結ぶ ε 又は a
と書かれた矢印。</p>

<p>r|s の NFA は r の NFA と s の NFA から次のようにつくる:</p>

<p><img
alt="全体の初期状態から r と s の初期状態へと、r と s の受理状態から全体の受理状態へ ε で結ぶ"
src="lec3img2.png" /></p>

<h1>正規表現から NFA へ (2)</h1>

<p>rs の NFA は r の受理状態と s の初期状態を ε
で結んで、r の初期状態は rs の初期状態、s の受理状態は
rsの受理状態。</p>

<p>r* の NFA は次のようにつくる:</p>

<p><img
alt="全体の初期状態と r の初期状態、r の受理状態と全体の受理状態、全体の初期状態と全体の受理状態、そして r の受理状態と初期状態 (逆!) を ε で結ぶ。"
src="lec3img3.png" /></p>

<h1>有限オートマトンから正規表現へ</h1>

<p>変換は可能だけど、面倒くさい。</p>

<p>変換の原理:</p>
<ol>
  <li>状態 A から状態 B
    へ<strong>直接</strong>遷移できる正規表現を全ての状態の組み合わせのために作る。</li>
  <li>一個の状態だけをを選んで、その状態をの経由を含める正規表現を作る。</li>
  <li>2.
    のステップを繰り返して、経由できる状態を増やす。</li>
  <li>途中で正規表現がどんどん複雑になるので、できる限り簡単化する</li>
</ol>

<h1>コンパイラの段階</h1>

<p>字句解析 (lexical analysis)</p>

<p>構文解析 (parsing; syntax analysis)</p>

<p>意味解析 (semantic analysis)</p>

<p>最適化 (optimization)</p>

<p>コード生成 (code generation)</p>

<h1>コンパイラの構造の実装</h1>

<p>前半 (解析) もしくは全体は構文解析が中心</p>

<p>構文解析は getNextToken()
みたいな関数で字句解析から必要におおじてトーケンを取り寄せる</p>

<p>構文解析は必要におおじて意味解析などを呼ぶ</p>

<h1>字句解析の実装</h1>

<p>主な要点:</p>
<ul>
  <li>細かい作業なので効率が大切</li>
  <li>読み込みにバッファを使う</li>
</ul>

<p>選択肢:</p>
<ul>
  <li>自分で字句分析を書く</li>
  <li>ツールを使う</li>
</ul>

<h1>今週のまとめ</h1>
<ul>
  <li>正規表現、線形・正規文法、有限オートマトンは皆同じ表現・受理能力を持つ。</li>
  <li>DFA による効率良い受理プログラムが作れる。</li>
  <li>正規表現のコンパクトな定義方法がある。</li>
  <li>これらは字句解析に有効に使える。</li>
  <li>しかし、これらに表現できない言語がある。状態の有限な数によって、例えば一般の括弧の対応する言語は判定できない。</li>
</ul>

<h1>宿題 (提出不要)</h1>

<p><del>提出は A4 の紙一枚 (裏も使ってよい)</del></p>
<ol>
  <li>次の正規表現を NFA に変換して、NFA から DFA を作る。
    <p><code>a(b|c)*a</code></p>
  </li>
  <li>1.
    の言語を定義する<del>左</del><ins>右</ins>線形文法を作る。</li>
  <li>Σ = {0, 1} の 0 が偶数の語を受理する DFA を作る。</li>
  <li>(発展問題) <del>2.</del><ins>3.</ins>
    の言語の正規表現を作る。(ヒント:
    変換するより正規表現を新たに作る方がいい)</li>
</ol>

<h1>来週の予定と準備</h1>

<p>予定:</p>
<ul>
  <li>ミニテスト (flex 以外今までの内容)</li>
  <li>flex の演習</li>
</ul>

<p>準備:</p>
<ul>
  <li>flex, gcc, bison の動作確認済みのノートPC を持参</li>
</ul>
</body>
</html>
